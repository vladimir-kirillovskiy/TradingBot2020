# В account activities и в portfolio history время хранится в разних форматах
# Valid timeframe for days > 7 are [5Min 15Min 1H 1D]
# Valid timeframe for days > 30 is 1D


# Строим график изменения прибыли за указанное время
def visual_history(api, period, time_frame, date_start, date_end):
    history = api.get_portfolio_history(period=period, timeframe=time_frame, date_start=date_start,
                                        date_end=date_end)  # Получаем всю историю аккаунта за указанное время
    x = []
    for each in history.timestamp:
        # Переводим время в формат "YYYY-MM-DDTHH:MM:SS"
        x.append(datetime.datetime.isoformat(datetime.datetime.fromtimestamp(each)))
    y = history.equity
    return x, y


# Получаем точки, в которые были исполненны ордеры на покупку/продажу
def get_dots(api, date_start, date_end, time_frame, time_example='2020-07-16T16:30:00'):
    sells = set()  # Точки, в которые выполнены ордеры типа sell
    buys = set()  # Точки, в которых выполнены ордеры типа buy
    delta = datetime.timedelta(days=1)
    day = date_start
    while day <= date_end:  # Проходим все дни от начала до конца, каждый раз выгружая все активити типа fill, в итоге обращений к API будет столько, сколько дней мы рассматриваем
        orders = api.get_activities(activity_types='FILL', date=day)  # Получаем активити за день
        for order in orders:  # Для каждого ордера представляем дату в удобном для обработки формате (строка), отсекая при этом часовой пояс, чтобы далее можно было окргулить время
            isoform = datetime.datetime.fromtimestamp(datetime.datetime.timestamp(order.transaction_time))  # Отсекаем часовой пояс
            isoform = str(isoform)
            isoform = isoform[:10] + 'T' + isoform[11:]  # Приводим время к формату isoform  # В итоге получится дата вида '2020-07-16T16:30:00', уже в нашем часовом поясе
            
            # Далее в зависимости от тайм фрейма окргуляем время, чтобы у точек ордеров и графика прибыли совпадала ось времени 
            if time_frame == '1Min':
                isoform = isoform[:-10]
                ost = time_example[-3:]
                isoform += ost
            elif time_frame == '5Min':
                isoform_ost = isoform[-11]
                ost = time_example[-4:]
                isoform = isoform[:-11]
                isoform_ost = (int(ost[0]) + ((int(isoform_ost) - int(ost[0])) // 5) * 5) % 10
                isoform += str(isoform_ost) + ost[-3:]
            elif time_frame == '15Min':
                isoform_ost = isoform[-12:-10]
                ost = time_example[-5:]
                isoform_ost = (int(ost[:2]) + ((int(isoform_ost) - int(ost[:2])) // 15) * 15) % 60
                if isoform_ost < 10:
                    isoform_ost = '0' + str(isoform_ost)
                else:
                    isoform_ost = str(isoform_ost)
                isoform = isoform[:-12]
                isoform += isoform_ost + ost[2:]
            elif time_frame == '1H':
                ost = time_example[-6:]
                isoform = isoform[:-13]
                isoform += ost
            else:
                ost = time_example[-9:]
                isoform = isoform[:-16]
                isoform += ost
                
            # Заполняем множества точек покупок и продаж    
            if order.side == 'buy':
                buys.add(isoform)
            else:
                sells.add(isoform)
        day += delta  # Изменяем текущий день
    return sells, buys  # Два множества



# Проверка полученных данных, чтобы не возникало конфликтов с api
def check_input(period, time_frame, date_start, date_end):
    if date_end and not date_start and not period:
        return 4  # 4 - Необходимо указать дополнительно или период, или дату начала
    elif date_start and not date_end and not period:
        return 5  # 5 - Необходимо указать дополнительно или период, или дату конца
    if period:
        if period[-1] == 'n' and len(period) > 3:
            num = int(period[:-3])
            unit = period[-3:]
            if unit != 'Min':
                return 0  # 0 - wrong time_frame
        elif period[-1] == 'n' and len(period) <= 3:
            return 0  # 0 - wrong time_frame
        else:
            num = int(period[:-1])
            unit = period[-1]
            if unit not in ['H', 'D']:
                return 0  # 0 - wrong time_frame
        if date_start and date_end:
            return 1  # 1 - Задан и период, и время начала, и время конца
        elif num > 7 and unit == 'D' and time_frame == '1Min':
            return 2  # 2 - Valid time_frame for days > 7 are [5Min 15Min 1H 1D]
        elif num > 30 and unit == 'D' and time_frame != '1D':
            return 3  # Valid time_frame for days > 30 is 1D
        else:
            return 100  # Correct

    # Приводим даты к одному виду
    if date_start:
        start = date_start.split('-')
        start = datetime.date(int(start[0]), int(start[1]), int(start[2]))
    if date_end:
        end = date_end.split('-')
        end = datetime.date(int(end[0]), int(end[1]), int(end[2]))
    today = datetime.date.today()

    # Если не задан период, приходится вычислять, сколько дней между date_start и date_end
    if (date_end and date_start and abs(int(str(end - start).split()[0])) > 7) and time_frame == '1Min':
        return 2  # 2 - Valid time_frame for days > 7 are [5Min 15Min 1H 1D]
    elif (date_start and not date_end and abs(int(str(today - start).split()[0])) > 7) and time_frame == '1Min':
        return 2  # 2 - Valid time_frame for days > 7 are [5Min 15Min 1H 1D]
    elif (date_end and date_start and abs(int(str(end - start).split()[0])) > 30) and time_frame != '1D':
        return 3  # Valid time_frame for days > 30 is 1D
    elif (date_start and not date_end and abs(int(str(today - start).split()[0])) > 30) and time_frame != '1D':
        return 3  # Valid time_frame for days > 30 is 1D
    return 100  # Correct


# Основная функция для отрисовки графика с маркерами и кривой
def visualization(api, period=None, time_frame='1D', date_start=None, date_end=None):
    # Time_frame может принимать значения '1Min', '5Min', '15Min', '1H', or '1D'
    # Period: The duration of the data in <number> + <unit>, such as 1D, where <unit> can be D for day,
    # W for week, M for month and A for year.
    # The date in “YYYY-MM-DD” format

    check = check_input(period, time_frame, date_start, date_end)  # Проверяем данные на корректность
    if check == 0:
        return 'Неверный time_frame'
    elif check == 1:
        return 'Слишком много данных'
    elif check == 2:
        return 'Valid time_frame for days > 7 are [5Min 15Min 1H 1D]'
    elif check == 3:
        return 'Valid time_frame for days > 30 is 1D'
    elif check == 4:
        return 'Необходимо указать дополнительно или период, или дату начала'
    elif check == 5:
        return 'Необходимо указать дополнительно или период, или дату конца '
    elif check == 100:  # Если проверка успешно пройдена
        x, y = visual_history(api, period, time_frame, date_start, date_end) # Получаем данные для построения графика прибыли, x - время, y - прибыль

        # Если не заданы date_start или date_end, или оба, вычисляем их сами, чтобы в будущем можно было вызывать функцию получения точек
        if period and not date_start and not date_end:
            if period[-1] == 'D':
                days = period[:-1]
                date_end = datetime.date.today()
                date_start = date_end - datetime.timedelta(days=int(days))
            else:
                date_end = date_start = datetime.date.today()
        elif period and not date_start:
            if period[-1] == 'D':
                days = period[:-1]
                date_start = date_end - datetime.timedelta(days=int(days))
            else:
                date_start = datetime.date.today()
        elif period and not date_end:
            if period[-1] == 'D':
                days = period[:-1]
                date_end = date_start + datetime.timedelta(days=days)
                
        sell_dots, buy_dots = get_dots(api, date_start, date_end, time_frame, time_example=x[0])  # Получаем точки 

        # Делим точки полученных множеств на три типа: только покупка, только продажа, и то, и другое
        sell_x = []  # Время, в которое были выполнены ордеры на покупку
        sell_y = []  # Прибыль в это время

        buy_x = []  # Время, в которое были выполнены ордеры на продажу
        buy_y = []  # Прибыль в это время

        sell_buy_x = []  # Время, в которое были выполнены ордеры и на покупку, и на продажу
        sell_buy_y = []  # Прибыль в это временя

        for i in range(len(x)):
            if x[i] in sell_dots and x[i] in buy_dots:
                sell_buy_x.append(x[i])
                sell_buy_y.append(y[i])
            elif x[i] in sell_dots:
                sell_x.append(x[i])
                sell_y.append(y[i])
            elif x[i] in buy_dots:
                buy_x.append(x[i])
                buy_y.append(y[i])
        
        # Само построение графика
        fig = go.Figure()
        fig.add_trace(go.Scatter(x=x, y=y, name='$', mode='lines'))
        fig.add_trace(
            go.Scatter(x=sell_buy_x, y=sell_buy_y, name='sell+buy', mode='markers',
                       marker=dict(size=8, color='#000000')))
        fig.add_trace(go.Scatter(x=sell_x, y=sell_y, name='sell', mode='markers', marker=dict(size=8, color='#ff0000')))
        fig.add_trace(go.Scatter(x=buy_x, y=buy_y, name='buy', mode='markers', marker=dict(size=8, color='#00ff00')))
        fig.layout.xaxis.type = 'category'

        fig.show()
        return 'Done'
